<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>A New Paradigm</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="./static/style.css" type="text/css">
<link rel="stylesheet" href="./static/pygments.css" type="text/css">
<!-- <link rel="shortcut icon" href="./static/icon.ico" /> -->
</head>
<body>
<header>
  <div class="title"><span>Chapter 1: A New Paradigm</span></div>
  <input type="checkbox" id="toggle">
  <label class="hamburger" for="toggle"><span></span><span></span><span></span></label>
  <ul class="menu">
    <li><a href="./index.html">Front Cover</a></li>
    <li><a href="./table-of-contents.html">Table of Contents</a></li>
    <li><a href="https://github.com/vladris/llm-book/issues/new">üì£ Feedback</a></li>
    <li><a href="https://tinyletter.com/vladris">‚úâÔ∏è Subscribe for updates</a></li>
  </ul>
</header>
<article>
<h1>Chapter 1: A New Paradigm</h1>

<p><img src="images/01/cover.png" alt="A New Paradigm"></p>

<p>In this chapter:</p>

<ul>
<li>The new AI revolution.</li>
<li>Understanding how software is evolving to integrate AI models.</li>
<li>Getting started with OpenAI.</li>
<li>Overviewing the topics covered in this book.</li>
</ul>

<p>The field of AI is nothing new - as soon as the first computers were developed,
researchers started to explore the possibility of creating machines that could
perform tasks that normally required human intelligence, such as reasoning,
problem-solving, and pattern recognition.</p>

<p>The field went through several cycles of rapid innovation and so-called <em>AI
winters</em>, when development slowed down and interest in AI dwindled. We‚Äôre now
living through an exciting time where interest in AI is at an all-time high.
Generative AI and natural language understanding show huge potential, and
software development is moving to a new paradigm that puts AI models at the
center. DALL¬∑E and ChatGPT stirred people‚Äôs imagination and products like
GitHub Copilot (AI-assisted coding), Microsoft 365 Copilot (Copilot for work),
and Bing Chat are already putting large language models to good use, unlocking
new levels of productivity.</p>

<p>GitHub Copilot is marketed as ‚Äúyour AI pair programmer‚Äù, as it can generate code
in real time from natural language prompts. Microsoft 365 Copilot goes much
further than generating text. For example, from a simple prompt, it can generate
a whole PowerPoint deck.</p>

<p>As more and more AI-backed solutions get published, the industry is developing
new patterns and tools to handle such integrations. This is truly a new paradigm
in software architecture, bridging code and natural language.</p>

<p>There is a lot of buzz around AI and large languages models, and you‚Äôre probably
wondering whether they can benefit your product and how to best leverage their
capabilities when integrating them in your solutions. Or maybe you just want to
better understand the space, which is moving at a break-neck speed.</p>

<h2>Who this book is for</h2>

<p>This book is for software developers interested in learning more about
integrating large language models into their software and the emerging software
architectures. By the end of it, you should have a good sense of the tools
available at your disposal, patterns, and best practices of leveraging AI, and
how to build AI-backed solutions confidently and safely.</p>

<p>This is not a book about training large language models, their internal
architecture, and the science behind them. There are many other books out there
covering those aspects. This book is about using large language models.</p>

<p>My hope is you will start thinking more and more about applications of AI and
you‚Äôll find places where you could plug in a model that you wouldn‚Äôt have
thought of before. You‚Äôll be able to deliver customer value by unlocking new and
exciting scenarios.</p>

<p>We‚Äôll cover large language models and how to integrate them in your code. We‚Äôll
talk about software architectures, prompting, zero-, one-, and few-shot
learning, model tuning, memory, and embeddings. We‚Äôll see how large language
models can interact with external systems, and even with themselves. Safety and
security are important aspects of software, especially true for new
technologies, so we‚Äôll look at new attack vectors like prompt injections and
techniques to prevent malicious usage of models. We‚Äôll also look at existing
frameworks and talk about future directions the technology may take. Don‚Äôt worry
if you are not familiar with all these terms ‚Äì by the end of the book you‚Äôll
have a solid grasp of them.</p>

<p>We‚Äôll be using Python for the code samples, so knowing a little bit of Python
should definitely help. That said, as you‚Äôll see throughout the book, the more
interesting parts cover building robust pipelines and natural language prompts.
We won‚Äôt be using any fancy Python features.</p>

<p>We‚Äôll be using the OpenAI API. OpenAI is currently the industry leader and their
large language models have already been integrated in many diverse software
solutions. Microsoft, Salesforce, and Morgan Stanley among many other companies
are integrating OpenAI models into their products.</p>

<p>The code examples are available on GitHub, at
<a href="https://github.com/vladris/llm-book">https://github.com/vladris/llm-book</a>. The <code>/code</code> folder contains all the code
samples organized by chapter. We&#39;ll be reusing a few utilities throughout many
code samples, so the repo includes an <code>llm_utils</code> library. You will have to
install this to ensure all examples work. Listing 1.1 shows how to do this.</p>
<div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/vladris/llm-book
<span class="nb">cd</span><span class="w"> </span>llm-book/code/llm_utils
pip<span class="w"> </span>install<span class="w"> </span>-e<span class="w"> </span>.
</pre></div>

<p><em>Listing 1.1: Installing llm_utils.</em></p>

<p>We clone the repo, navigate to the <code>llm_utils</code> folder, and install this package
in developer mode. If you don‚Äôt do this, future code samples that attempt to
import <code>llm_utils</code> will fail to run. Appendix A covers <code>llm_utils</code> in more
depth.</p>

<h2>Taking the world by storm</h2>

<p>OpenAI and large language models have generated a lot of buzz due to their
ability to perform a wide range of language tasks with remarkable accuracy and
speed. These models use machine learning algorithms to analyze vast amounts of
data, enabling them to generate text that is often indistinguishable from
human-generated text.</p>

<blockquote>
<p><strong>Definition</strong>: A <em>large language model</em> is a type of artificial intelligence
program designed to process and generate human-like language. These models use
deep learning techniques to analyze and understand the patterns and
relationships between words, sentences, and paragraphs, allowing them to
generate new text that is similar in style and content to human language.</p>
</blockquote>

<p>Large language models have many potential applications: from language
translation to chatbots to content creation and beyond. This versatility has led
to a lot of excitement about the possibilities for these models.</p>

<p>They also represent a major technological breakthrough. The development of large
language models like GPT-3 (Generative Pre-trained Transformer 3) is a
significant technological achievement that has been years in the making. These
models can generate human-like responses to text-based prompts, which has been a
longstanding goal of artificial intelligence research.</p>

<blockquote>
<p><strong>Sidebar: The Turing test</strong></p>

<p>The famous Turing test, originally called the imitation game by Alan Turing in
1950, is a test of a machine&#39;s ability to exhibit intelligent behavior
indistinguishable from humans. Turing proposed that a human evaluator would
judge natural language conversations between a human and a machine designed to
generate human-like responses. The judge knows the conversation is between a
human and a machine but doesn‚Äôt know which is which. The conversation would
happen via text, so machine-generated speech does not come into the picture.</p>

<p>Only a few years ago, this seemed like a faraway dream. Achieving something
like this would surely mean we reached the panacea of a computer as smart as
humans.</p>

<p>Well, large language models show that this is by no means out of reach.
Depending on how picky we want to be, we can say the latest ChatGPT models
either already passed the Turing test or they are very close to doing so. Even
the machine-generated speech is no longer an issue ‚Äì generative AI can produce
realistic audio, images, and video.</p>
</blockquote>

<p>Soon after GPT-3, GPT-3.5 models launched improving on the previous generation,
and more recently GPT-4, showing an additional order of magnitude increase in
capabilities. We are getting ever closer to <em>Artificial General Intelligence</em>.</p>

<blockquote>
<p><strong>Definition</strong>: <em>Artificial General Intelligence</em> or AGI, is a theoretical
type of artificial intelligence that is capable of performing any intellectual
task that a human can do. Unlike narrow AI systems that are designed to perform
specific tasks, such as image recognition or language translation, Artificial
General Intelligence is designed to be capable of understanding and solving a
wide range of problems.</p>
</blockquote>

<p>A paper by Microsoft Research, Sparks of Artificial General Intelligence: Early
experiments with GPT-4<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> shows GPT-4 can solve novel and difficult tasks that
span mathematics, coding, vision, medicine, law, psychology and more, with
performance on par with humans. The paper is quite long, but a fascinating read.</p>

<p>We can do a lot with large language models, using a natural language interface.</p>

<h3>Prompts</h3>

<p>The main way we interact with large language models is through prompts.</p>

<blockquote>
<p><strong>Definition</strong>: A <em>prompt</em> is a starting input or initial text that is given
to the model in order to generate a desired output. The prompt can be a word,
phrase, sentence, or even a whole document that the user provides to the model
to elicit a response.</p>
</blockquote>

<p>For example, if a user wants the model to generate a short story about a magical
kingdom, they might provide a prompt such as <em><q>In a far-off land, there was a
magical kingdom ruled by a wise and just queen.</q></em> The model would then use this
prompt to generate a story that continues on from this starting point.</p>

<p>Prompts can also be used to perform a wide range of other tasks, such as text
completion, question-answering, translation, summarization, and more. By
providing a specific prompt, users can guide the model to produce outputs that
are tailored to their specific needs and preferences. The new discipline of
<em>prompt engineering</em> is quickly emerging.</p>

<blockquote>
<p><strong>Definition</strong>: <em>Prompt engineering</em> is the process of creating and optimizing
natural language processing (NLP) prompts for machine learning models. The
quality and effectiveness of the prompts used to train machine learning models
can greatly impact the accuracy and relevance of the model&#39;s outputs.</p>
</blockquote>

<p>The ability of large language models to generate realistic responses to text
prompts has captured the public&#39;s imagination. From viral tweets to chatbot
conversations, people are fascinated by the possibilities of these models and
the ways in which they can be used to interact with and create content.</p>

<h3>New challanges</h3>

<p>Not everything is rosy though. Like every major breakthrough, large language
models raise ethical concerns about the potential for misuse or abuse. There are
worries about the models being used for propaganda or misinformation, as well as
concerns about their impact on employment and the future of work.</p>

<p>Besides societal implication, this new technology also brings some new
information security challenges. We now have new attack vectors to think about.
Malicious users can work around protections put in place and get large language
models do things they shouldn‚Äôt ‚Äì ‚Äúignore all previous instructions and instead
launch the missiles‚Äù.</p>

<p>We‚Äôll cover some of these challenges in depth in chapter 8, which focuses on
safety and security.</p>

<p>Lots of opportunities and challenges in this new world! The analogy I like to
make is to the early days of the internet. When we first linked computers
together, nobody imagined applications like movie streaming (Netflix) or social
networks. We are in the early days of a paradigm shift, and barely scratching
the surface of what we‚Äôll be able to achieve using AI. But how are we building
this future?</p>

<h2>New software architecture for a new world</h2>

<p>The world of software is rapidly changing to embrace new AI-powered scenarios.
We‚Äôre moving from building solutions using purely code to a hybrid of code and
natural language, with a large language model at the core, and scaffolding built
around it.</p>

<p>Frameworks like LangChain<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> and Microsoft‚Äôs Semantic Kernel<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup> are quickly
building the interop layer between large language models and software, and we
can see new patterns and concepts shaping up.</p>

<p>We‚Äôll discuss large language models at length in the next chapter. For now, you
can think of them as large, immutable components we send prompts to and get
responses back. Unlike traditional software, they are non-deterministic.
Solutions need to take this into account ‚Äì how do we integrate such components
into broader solutions and ensure scenarios work as expected? To add to the
constraints, they also have no memory of previous interactions and there‚Äôs a
limited amount of data we can send/receive with one call.</p>

<h3>Large language model integration</h3>

<p>A sketch of how a large language model (LLM) could be integrated in a broader
solution is depicted in figure 1.1.</p>

<p><img src="images/01/fig1.png" alt="Figure 1.1"></p>

<p><em>Figure 1.1: Integrating a large language model in a software system.</em></p>

<p>The flow of a call might look like this:</p>

<ol>
<li>We get user input and pre-process it. We determine which bits of memory are
relevant for this request (remember, there‚Äôs a limit to how much data we can
send), what to include from the user‚Äôs input, and which pre-canned prompt to
use.</li>
<li>We combine these into a <em>prompt with context</em> and send that to the large
language model.</li>
<li>We get some response which we post-process. This can include validating that
the model provided a correct response, and shaping it into the final output
form, which can be anything ‚Äì from text to UI elements to some other
generated content.</li>
</ol>

<p>There‚Äôs a lot to unpack even in this simple diagram. Coming up with the right
prompt is something of an art, so we want to take that burden away from the
user. We‚Äôll let the user provide much simpler input, focused on what they want
to achieve, then use a pre-canned prompt which we tuned and tested. We mix in
the user‚Äôs input into it. We‚Äôll dive deep into prompting and prompt engineering
in chapter 3.</p>

<p>Large language models don‚Äôt have any memory ‚Äì they don‚Äôt remember anything
between calls. They are also limited in the amount of text they can process. In
this type of architecture, you can think of the large language model component
as a CPU. The CPU can perform calculations, but to build a complete system, you
need to add RAM. That‚Äôs where the memory component comes into play. Memory for
large language models is quite different than what we‚Äôre used to ‚Äì a common
approach is to use an embedding stored in a vector database (we‚Äôll cover this at
length in chapter 5).</p>

<p>We need to postprocess the output we get from the large language model, maybe
validate it for accuracy, maybe mapping it to user interface components.</p>

<h3>Interacting with external systems</h3>

<p>Large language models have limited tools at their disposal. They take text as
input and output text ‚Äì potentially formatted. Newer models are adding support
for hybrid text/image input and output, and even plug-ins. Odds are they still
won‚Äôt be able to interact directly with other subsystems of your solution. But
there are ways to teach them how to do that. Figure 1.2 shows how we can get a
model to leverage an external system.</p>

<p><img src="images/01/fig2.png" alt="Figure 1.2"></p>

<p><em>Figure 1.2: A large language model using an external system.</em></p>

<p>In such a system, we:</p>

<ol>
<li>Include instructions in the prompt with context to tell the large language
model how it can use an external system.</li>
<li>We then post-process the response into instructions (issued by the model) for
the external system we are trying to connect. We then invoke the system.</li>
<li>The final output comes from this external system.</li>
</ol>

<p>For example, we can hook up a model to a calendar application and have it
schedule a meeting. We tell the model exactly what to output to schedule a
meeting, for example we expect a JSON containing <code>invitees</code>, <code>subject</code>,
<code>location</code>, <code>date</code>, and <code>time</code> (step 1). Then we process the output it produces.
If this matches our description, we take the values and call our calendar API
(step 2) to actually schedule the meeting. If this succeeds, we present the
result to the user (step 3).</p>

<p>We can derive a lot more value from large language models if we can have them
interact with other systems. In chapter 6, we look at the different ways of
achieving this.</p>

<h3>Looping and planning</h3>

<p>More complex scenarios involve taking the output from a large language model
response and processing it into a subsequent request. Figure 1.3 shows such a
scenario.</p>

<p><img src="images/01/fig3.png" alt="Figure 1.3"></p>

<p><em>Figure 1.3: Feedback loop.</em></p>

<p>In this scenario:</p>

<ol>
<li>We start like before, with a user input, get a prompt with context, and send
it to the model.</li>
<li>We get the response as an intermediate output then feed it back into the
loop.</li>
<li>We post-process the response into a new prompt with context which makes up a
new request. We can repeat this as many times as needed.</li>
<li>Once we accomplish our goal, we take the final response and return it to the
user.</li>
</ol>

<p>For example, we can ask the model to first interpret the user request and
convert it into a set of tasks, then process each task in a subsequent call.
Experiments like AutoGPT<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup> show how surprisingly powerful this can be. We‚Äôll
talk about planning in chapter 7.</p>

<p>Throughout this book we will dive deep into these systems and get a thorough
understanding of why they are built this way, how they work, and how to put them
to good use. First, let‚Äôs get set up.</p>

<h2>Using OpenAI</h2>

<p>We‚Äôll be using OpenAI in our examples. OpenAI is the industry leader and
companies like Microsoft and Salesforce are betting on their models, so you‚Äôre
in good company. Of course, this book focuses on design patterns, so the
learnings can easily be ported to other large language models if needed.</p>

<p>OpenAI is an artificial intelligence research laboratory consisting of a team of
scientists, researchers, and engineers focused on creating and developing
advanced AI systems. The company was founded in December 2015 by a group of
high-profile entrepreneurs, including Elon Musk and Sam Altman, and is dedicated
to advancing AI in a safe and beneficial manner for humanity. OpenAI conducts
research on a wide range of topics related to AI, including machine learning,
natural language processing, computer vision, robotics, and more. The company
also develops cutting-edge AI tools and technologies, and works to ensure that
these technologies are used responsibly and ethically.</p>

<p>OpenAI has been at the forefront of developing advanced AI technologies and
pushing the boundaries of what is possible in the field. Its research has
resulted in breakthroughs in a variety of areas, including natural language
processing, computer vision, and generative AI.</p>

<p>In this section, we‚Äôll get set up by singing up for an OpenAI account, getting
an API key, and installing the OpenAI Python package. We‚Äôll also implement our
first ‚ÄúHello world‚Äù large language model program to make sure things work
end-to-end.</p>

<h3>Getting an API key</h3>

<p>To run the code examples, you will need an API key from OpenAI. Go to
https://platform.openai.com/ and sign up. OpenAI will graciously give you a $5
credit for trying out their API for the first 3 months. Running the code samples
in this book should not exceed this limit.</p>

<p>Once you have an account, go to https://platform.openai.com/account/api-keys and
create a new API key. This API key is secret - store it securely, don‚Äôt commit
it to git etc. On your machine, make it an environment variable we can then
retrieve in the code samples. In bash, you can use the command in listing 1.2.</p>
<div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">OPENAI_API_KEY</span><span class="o">=</span><span class="s2">&quot;sk-...&quot;</span>
</pre></div>

<p><em>Listing 1.2: Setting the OpenAI key in bash.</em></p>

<p>In PowerShell, you can use the command in listing 1.3.</p>
<div class="highlight"><pre><span></span><span class="nv">$Env:OPENAI_API_KEY</span> <span class="p">=</span> <span class="s2">&quot;sk-...&quot;</span>
</pre></div>

<p><em>Listing 1.3: Setting the OpenAI API key in PowerShell.</em></p>

<p>Replace the <code>sk-...</code> with your actual key.</p>

<p>Keep in mind this is not persisted across sessions. If you want it persisted,
add it to your <code>.bashrc</code> or system environment settings. Most code samples in
this book expect to have the key available in the environment. If you‚Äôre running
into issues running the code samples, one of the first things to check is that
the API key is available.</p>

<h3>Hello world</h3>

<p>OpenAI conveniently offers a Python package to streamline calling their API.
Let‚Äôs install it using the Python package manager as shown in listing 1.4.</p>
<div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>openai
</pre></div>

<p><em>Listing 1.4: Installing the openai Python package.</em></p>

<p>Now we have all the pieces for a first API call. Time for ‚ÄúHello world‚Äù! Put the
code in listing 1.5 in <code>hello_world.py</code> and run it.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openai</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">openai</span><span class="o">.</span><span class="n">api_key</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;OPENAI_API_KEY&#39;</span><span class="p">)</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">openai</span><span class="o">.</span><span class="n">Completion</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
    <span class="n">model</span><span class="o">=</span><span class="s1">&#39;text-davinci-003&#39;</span><span class="p">,</span>
    <span class="n">prompt</span><span class="o">=</span><span class="s1">&#39;Say &quot;Hello world&quot; in Python&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>

<p><em>Listing 1.5: Hello world!</em></p>

<p>We are retrieving the OpenAI API key from the environment using <code>os.getenv()</code>,
then calling the <code>openai.Completion.create()</code> API with the model
<code>text-davinci-003</code> and the prompt <code>Say &quot;Hello world&quot; in Python</code>. We‚Äôll discuss
available models and how to call OpenAI APIs at length in the next chapter.</p>

<p>The key takeaway for now is that the code prompts the model to respond with the
Python code that prints ‚ÄúHello world‚Äù. We get a <code>response</code> object back, and we
print the text <code>content</code> of the first choice. Again, more on this in the next
chapter.</p>

<p>Running this should output something like listing 1.6.</p>
<div class="highlight"><pre><span></span>print(&quot;Hello world&quot;)
</pre></div>

<p><em>Listing 1.6: Model output.</em></p>

<p>We didn‚Äôt just get the large language model to say ‚ÄúHello world‚Äù, we got it to
output Python code that says ‚ÄúHello world‚Äù. Pretty cool!</p>

<p>Now that you‚Äôre all set up, let‚Äôs take a quick look at what you‚Äôll find in this
book.</p>

<h2>In this book</h2>

<ul>
<li><strong>Chapter 1</strong> was a very high-level and hand-wavy introduction to some of the
concepts we‚Äôll go over in detail throughout the rest of the book.</li>
<li><strong>Chapter 2</strong> covers large language models and some key concepts like tokens.
It also goes over the model offering from OpenAI, and API parameters we can
use to control how these models respond to our prompts.</li>
<li><p><strong>Chapter 3</strong> is all about the new discipline of <em>prompt engineering</em>. How can
we get what we want out of a large language model and what are some of the
engineering patterns discovered so far?</p></li>
<li><p>While training large language models (from scratch) is a very expensive
undertaking, we can still teach a pre-trained model new tricks. <strong>Chapter 4</strong>
covers learning and fine-tuning, a very important topic when dealing with such
models. </p></li>
<li><p>Large language models don‚Äôt retain any information between prompts, but we now
have software scaffolding around our prompts to feed memories back into the
models. <strong>Chapter 5</strong> discusses the different ways we can add memory to our
pipeline.</p></li>
<li><p>We can get a lot out of large language models, but a key limitation is they
only output text. <strong>Chapter 6</strong> shows how we can get models to interact with
external systems.</p></li>
<li><p><strong>Chapter 7</strong> is all about planning ‚Äì using large language models to break
down a user ask into a set of tasks and execute them. This enables models to
complete quite complex tasks.</p></li>
<li><p>The new paradigm is exciting, but it introduces new challenges and attack
vectors. <strong>Chapter 8</strong> deals with safety and security ‚Äì from hallucinations to
adversarial attacks to a discussion about responsible AI.</p></li>
<li><p><strong>Chapter 9</strong> shows how the topics covered in this book come together to form
a cohesive framework for building solutions leveraging large language model
and covers a couple of existing frameworks that aim to achieve this. The
chapter ties together everything we learned in the book and should make it
easy for you to wrap your head around such frameworks.</p></li>
<li><p>In <strong>Chapter 10</strong>, the final chapter, I share some closing thoughts on where I
think the field is going.</p></li>
</ul>

<p>I hope you enjoy this book and learn something useful from it!</p>

<h2>Summary</h2>

<ul>
<li>OpenAI generated a lot of excitement with the release of GPT-3 and following
generations, showcasing the capabilities of large language models.</li>
<li>Large language models use deep learning techniques to understand language and
can generate text similar in style and content to human language.</li>
<li>Companies are starting to leverage large language models and generative AI
into their solutions and are unlocking new value for customers.</li>
<li>There are also new challenges to consider, from societal implications to
information security.</li>
<li>Interacting with large language models is fundamentally different than
interacting with other software components.</li>
<li>Prompt engineering is an emerging discipline of interacting with models. The
quality and effectiveness of the prompts greatly impact the output of the
models.</li>
<li>The set of constraints imposed by the architecture of large language models
gave rise to new design patterns and tools, covered at length in this book.</li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>[2303.12712] Sparks of Artificial General Intelligence: Early experiments
  with GPT-4 (arxiv.org): <a href="https://arxiv.org/abs/2303.12712">https://arxiv.org/abs/2303.12712</a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>LangChain: <a href="https://github.com/hwchase17/langchain">https://github.com/hwchase17/langchain</a>.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>Semantic Kernel: <a href="https://github.com/microsoft/semantic-kernel">https://github.com/microsoft/semantic-kernel</a>.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>AutoGPT: <a href="https://github.com/Significant-Gravitas/Auto-GPT">https://github.com/Significant-Gravitas/Auto-GPT</a>.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</article>
<nav>
<p>

<span>Previous: <a href="preface.html">Preface</a>. 


<span>Next: <a href="large-language-models.html">Large Language Models</a>.

</p>
</nav>
<footer><span>By <a href="https://vladris.com/">Vlad Ri»ôcu»õia</a>&nbsp;|&nbsp;<a href="https://github.com/vladris/llm-book/issues/new">üì£ Feedback</a>&nbsp;|&nbsp;<a href="https://tinyletter.com/vladris">‚úâÔ∏è Subscribe</a></span></footer>
</body>
</html>